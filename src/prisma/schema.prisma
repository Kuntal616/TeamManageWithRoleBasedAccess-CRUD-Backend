generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// User model with role and team association
//1:1 relation between User and Team (models are connected via teamId in User model)
// Each user can belong to one team, and each team can have multiple users
model User {
  id              String    @id @default(cuid())
  email           String    @unique
  password        String
  name            String
  role            Role      @default(USER)
  tasks           Task[] // 1:N relation between User and Task (assignee)
  comments        Comment[] // 1:N relation between User and Comment (author)
  projectsCreated Project[] // 1:N relation between User and Project (creator)
  // Relations
  teamId          String?
  team            Team?     @relation(fields: [teamId], references: [id], onDelete: SetNull)
  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Indexes
  @@index([email])
  @@index([role])
  @@index([teamId])
  //map
  @@map("users")
}

//1:N relation between Team and User
model Team {
  id          String    @id @default(cuid())
  name        String    @unique
  description String?
  code        String    @unique
  members     User[]
  projects    Project[]
  // Relations

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  //map
  @@map("teams")
}

//1:N relation between Team and Project
// Each team can have multiple projects, but each project belongs to one team
// Each project is created by a user
//each user can create multiple projects
model Project {
  id          String  @id @default(cuid())
  name        String
  description String?

  teamId String
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  tasks       Task[]
  createdById String
  createdBy   User     @relation(fields: [createdById], references: [id])
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([name, teamId])
  @@index([teamId])
  @@map("projects")
}

//1:N relation between Project and Task
model Task {
  id          String       @id @default(cuid())
  title       String
  description String?
  status      TaskStatus   @default(PENDING)
  priority    TaskPriority @default(NORMAL)
  dueTime     DateTime?

  projectId String
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  assigneeId String?
  assignee   User?   @relation(fields: [assigneeId], references: [id], onDelete: SetNull)

  comments Comment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([projectId])
  @@index([assigneeId])
  @@map("tasks")
}

//1:N relation between Task and Comment
model Comment {
  id      String @id @default(cuid())
  content String

  taskId String
  task   Task   @relation(fields: [taskId], references: [id], onDelete: Cascade)

  authorId String?
  author   User?   @relation(fields: [authorId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("comments")
}

enum TaskStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  ON_HOLD
}

enum TaskPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

enum Role {
  ADMIN
  MANAGER
  USER
  GUEST
}
